#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# This file is part of "convert2ugrid" tool
#
# Author: Nikolai Chernikov, nikolai.chernikov.ru@gmail.com


import process_mossco_netcdf
import numpy as np


def create_magnitude_variable_from_x_y_component(VARS, varname, varval, mask=None, log=False):
    '''
    in:
    ----
        VARS     - dictionary generated by function process_cdl.read_file_with_only_variables()
        varname  - string, item-key of a dictionary VARS, should correspond to varval
        varval   - item-value of a dictionary VARS, should correspond to varname
                    varval[0] >>> datatype
                    varval[1] >>> [dim1,dim2,...]
                    varval[2] >>> dict(attributes)
                    Note: all values are stored as strings
    out:
    ----
        magnitude - False, or Ndimensional numpy array (maybe masked, depending on the inputs).
                    It will usually be 1D array (<...> in selections such as x[t, ..., f] is made
                    to increase flexibility of accepted variables. Nevertheless mostly it will be x[t, f])

    '''
    magnitude = None
    # -----------------------------------------------------------------------------------------------
    # Create auto variables
    # -----------------------------------------------------------------------------------------------
    if '_auto_creation' in varval[2].keys():
        if log: print 'Autocreation-variable'
        _fnx = VARS[ varval[2]['_auto_creation'].split(',')[0].strip() ] [2]['_mossco_filename']
        _fny = VARS[ varval[2]['_auto_creation'].split(',')[1].strip() ] [2]['_mossco_filename']
        _vnx = VARS[ varval[2]['_auto_creation'].split(',')[0].strip() ] [2]['_mossco_varname']
        _vny = VARS[ varval[2]['_auto_creation'].split(',')[1].strip() ] [2]['_mossco_varname']

        # -----------------------------------------------------------------------------------------------
        # now check which function (read_mossco_nc_3d, read_mossco_nc_4d) to use to get data....
        # -----------------------------------------------------------------------------------------------
        if varname.endswith('_2d'):
            x, _ = process_mossco_netcdf.read_mossco_nc_3d(_fnx, _vnx, mask=mask)
            y, _ = process_mossco_netcdf.read_mossco_nc_3d(_fny, _vny, mask=mask)
            magnitude = np.zeros(x.shape)
            for t in xrange(x.shape[0]):
                for f in xrange(x.shape[-1]):
                    _x = x[t, ..., f]
                    _y = y[t, ..., f]
                    _magnitude = (_x**2 + _y**2)**(1./2.)
                    magnitude[t, ..., f] = _magnitude

        elif varname.endswith('_3d'):
            x, _ = process_mossco_netcdf.read_mossco_nc_4d(_fnx, _vnx, mask=mask)
            y, _ = process_mossco_netcdf.read_mossco_nc_4d(_fny, _vny, mask=mask)
            magnitude = np.zeros(x.shape)
            for t in xrange(x.shape[0]):
                for z in xrange(x.shape[1]):
                    for f in xrange(x.shape[-1]):
                        _x = x[t, z, ..., f]
                        _y = y[t, z, ..., f]
                        _magnitude = (_x**2 + _y**2)**(1./2.)
                        magnitude[t, ..., f] = _magnitude

    return magnitude


def create_layer_elevation_from_sigma_coords(eta, sigma, depth, flatten=False, mask=None, log=False):
    '''
    create elevations <z> with respect to MSL of passed sigma-coordinates.

    Calculations are performed in accordance with CF-conventions (CF 1.6)
    for variable "Ocean Sigma Coordinate" as...
        z(n,k,j,i) = eta(n,j,i) + sigma(k)*(depth(j,i)+eta(n,j,i))

        where:
            z, eta, sigma, depth - numpy arrays
            n   - integer, timesteps
            k   - integer, layers
            j,i - integer, y,x indices

    flatten - if True, x,y dimensions of the array will be compressed into one single
    mask    - boolean 2d mask to ignore elements during flattening. see <process_mossco_netcdf.make_mask_array_from_mossco_bathymetry()>
    '''
    if log:
        _name = 'create_layer_elevation_from_sigma_coords():'
        print _name, 'Shapes of the inputs...'
        print _name, 'eta: <{0}>, sigma: <{1}>, depth: <{2}>'.format(eta.shape, sigma.shape, depth.shape)
    
    elev         = np.zeros((eta.shape[0], len(sigma), eta.shape[1], eta.shape[2]))
    elev_borders = np.zeros((2, eta.shape[0], len(sigma), eta.shape[1], eta.shape[2]))

    # create sigma coordinates of the borders
    sigma_borders = np.zeros(len(sigma)+1)
    sigma_borders[0] = -1.  # coordinate of the very bottom
    for z in xrange(len(sigma)):
        sigma_borders[z+1] = sigma_borders[z] - (sigma_borders[z] - sigma[z])*2
    

    if abs(sigma_borders[-1]) > 0.005:
        print _name, 'sigma layer centers', sigma
        print _name, 'sigma layer borders', sigma_borders
        raise ValueError('Sigma values for layer-borders calculated not correctly')
    else:
        sigma_borders[-1] = 0.  # corrdinate of the very top

    if log: print _name, 'sigma layer centers', sigma
    if log: print _name, 'sigma layer borders', sigma_borders
    


    for t in xrange(elev.shape[0]):
        for z in xrange(elev.shape[1]):
            elev[t, z, ...] = eta[t, ...] + sigma[z]*(depth + eta[t, ...])
            for border in xrange(2):
                elev_borders[border, t, z, ...] = eta[t, ...] + sigma_borders[z+border]*(depth + eta[t, ...])
            #if log: print 't=', t, 'z=', z, 'elev:', elev[t, z, 12, 12]
            #if log: print 't=', t, 'z=', z, 'elev_bnb [0]:', elev_borders[0, t, z, 12, 12]
            #if log: print 't=', t, 'z=', z, 'elev_bnb [1]:', elev_borders[1, t, z, 12, 12]
    



    if log: print _name, 'Elevation array created of shape <{0}>'.format(elev.shape)
    if log: print _name, 'Elevation border array created of shape <{0}>'.format(elev_borders.shape)
    return elev, elev_borders



def create_sigma_coords_of_layer_center(sigma_border):
    '''
        creates arrays of sigma-coordinates for layer centers, when a
        corresponding array is given for the layer borders
    '''

    sigma_center = np.zeros(len(sigma_border)-1)

    for z in xrange(sigma_center.__len__()):
        sigma_center[z] = .5*(sigma_border[z] + sigma_border[z+1])
    return sigma_center






def flatten_xy_data(data, mask=None):
    if mask is None:
        
        dims = list(data.shape[:-2])
        dims.append(data.shape[-1]*data.shape[-2])

        a = np.zeros(dims)
        if len(dims) == 3:
            for t in xrange(data.shape[0]):
                for z in xrange(data.shape[1]):
                    a[t, z, :] = data[t, z, ...].T.flatten(1)  # why not <.flatten(order='F')> ??? what is the difference?
        elif len(dims) == 2:
            for t in xrange(data.shape[0]):
                a[t, :] = data[t, ...].T.flatten(1)  # why not <.flatten(order='F')> ??? what is the difference?
        elif len(dims) == 1:
            a[:] = data[...].T.flatten(1)  # why not <.flatten(order='F')> ??? what is the difference?

        elif len(dims) == 4 and dims[0] == 2:  # if we have boundary var (i.e. Mesh2_face_bnd(two, t, z, face))
            del a
            dims.append(2)
            a = np.zeros(dims[1::])  # make the dimension two appear at the end... (two, t, z, face) => (t, z, face, two)

            for t in xrange(data.shape[1]):
                for z in xrange(data.shape[2]):
                    for bnd in xrange(data.shape[0]):
                        a[t, z, :, bnd] = data[bnd, t, z, ...].T.flatten(1)  # why not <.flatten(order='F')> ??? what is the difference?
        else:
            raise ValueError('Number of array dimensions <{0}> is not supported.'.format(len(dims)))
    else:
        n_valid_2d = np.sum(np.invert(mask))  #number of valid elements in 2d part. invert - because True is an invalid element
        
        dims = list(data.shape[:-2])
        dims.append(n_valid_2d)

        a = np.zeros(dims)

        if len(dims) == 3:
            for t in xrange(data.shape[0]):
                for z in xrange(data.shape[1]):
                    var_masked = np.ma.array(data[t, z, ...], mask=mask.T).T
                    var_masked = var_masked.flatten(order='F').compressed()
                    a[t, z, :] = var_masked
        elif len(dims) == 2:
            for t in xrange(data.shape[0]):
                var_masked = np.ma.array(data[t, ...], mask=mask.T).T
                var_masked = var_masked.flatten(order='F').compressed()
                a[t, :] = var_masked
        elif len(dims) == 2:
            var_masked = np.ma.array(data[...], mask=mask.T).T
            var_masked = var_masked.flatten(order='F').compressed()
            a[:] = var_masked
        elif len(dims) == 4 and dims[0] == 2:  # if we have boundary var (i.e. Mesh2_face_bnd(two, t, z, face))
            del a
            dims.append(2)
            a = np.zeros(dims[1::])  # make the dimension two appear at the end... (two, t, z, face) => (t, z, face, two)
            for t in xrange(data.shape[1]):
                for z in xrange(data.shape[2]):
                    for bnd in xrange(data.shape[0]):
                        var_masked = np.ma.array(data[bnd, t, z, ...], mask=mask.T).T
                        var_masked = var_masked.flatten(order='F').compressed()
                        a[t, z, :, bnd] = var_masked
        else:
            raise ValueError('Number of array dimensions <{0}> is not supported.'.format(len(dims)))

    return a
